"""
In this file we have some utility functions for checking and correcting the react code generated by the explainer agent
"""
import re
import subprocess
import json
import tempfile
import os
import shutil


class ESLintValidator:
    def __init__(self):
        """
        Initializes the validator. The configuration files are expected to be
        pre-installed in /opt/eslint-setup/
        """
        self.script_dir = os.path.dirname(os.path.realpath(__file__))
        self.eslint_setup_dir = '/opt/eslint-setup'

        # Fallback to local files if running outside Docker
        if not os.path.exists(self.eslint_setup_dir):
            self.eslint_setup_dir = self.script_dir

        self.config_file_path = os.path.join(self.eslint_setup_dir, 'eslint.config.js')
        self.package_json_path = os.path.join(self.eslint_setup_dir, 'package.json')
        self.node_modules_path = os.path.join(self.eslint_setup_dir, 'node_modules')

        # Check that the required files exist
        if not os.path.exists(self.config_file_path):
            raise FileNotFoundError(f"Required file not found: {self.config_file_path}")
        if not os.path.exists(self.package_json_path):
            raise FileNotFoundError(f"Required file not found: {self.package_json_path}")

    def validate_jsx(self, jsx_code):
        """
        Validates JSX by creating a temporary file and running ESLint from the pre-installed directory.
        """
        # jsx_code = find_react_code_in_response(jsx_code_input) # Bypass for now

        # --- TEMPORARY TEST --- 
        jsx_code = """() => {
    const headerStyle = {
        color: red, // Undefined variable
        borderBottom: '2px solid #007bff'
    };
    return <div style={headerStyle}>Test<div>;
}
"""

        print("Starting to parse jsx code:")
        print(jsx_code)

        if not (jsx_code.startswith("(") or jsx_code.startswith("const") or jsx_code.startswith("function")):
            return {
                'valid': False,
                'errors': [{'message': f"""
                Your output format is wrong. Your response should start with () => {{ and end with }}, 
                but your response starts with {jsx_code[:10]}
                """}]
            }

        with tempfile.TemporaryDirectory() as temp_dir:
            try:
                # Write the JSX code to be linted in the temp directory
                js_file_to_lint = os.path.join(temp_dir, 'temp.jsx')
                with open(js_file_to_lint, 'w', encoding='utf-8') as f:
                    f.write(jsx_code)

                # Run ESLint from the pre-installed directory, but lint the temp file
                if os.path.exists(self.node_modules_path):
                    # Use the pre-installed ESLint with absolute path to the temp file
                    eslint_bin = os.path.join(self.node_modules_path, '.bin', 'eslint')
                    lint_process = subprocess.run([
                        eslint_bin,
                        '--config', self.config_file_path,
                        '--quiet',
                        '--format', 'json',
                        js_file_to_lint  # Absolute path to the file in temp directory
                    ], capture_output=True, text=True, cwd=self.eslint_setup_dir)
                else:
                    # Fallback for local development: run npm install and use local ESLint
                    shutil.copy(self.config_file_path, temp_dir)
                    shutil.copy(self.package_json_path, temp_dir)

                    subprocess.run(
                        ['npm', 'install'],
                        cwd=temp_dir,
                        capture_output=True,
                        text=True,
                        check=True
                    )

                    lint_process = subprocess.run([
                        'npx', 'eslint',
                        '--format', 'json',
                        js_file_to_lint
                    ], capture_output=True, text=True, cwd=temp_dir)

                print(f"--- ESLint STDOUT ---\n{lint_process.stdout}\n-----------------------")
                print(f"--- ESLint STDERR ---\n{lint_process.stderr}\n-----------------------")

                if lint_process.stdout:
                    return self._parse_eslint_output(lint_process.stdout)

                return {
                    'valid': False,
                    'errors': [{'message': lint_process.stderr.strip()}] if lint_process.stderr else []
                }

            except subprocess.CalledProcessError as e:
                return {
                    'valid': False,
                    'errors': [{'message': f"ESLint execution failed: {e.stderr}"}]
                }
            except Exception as e:
                return {'valid': False, 'errors': [{'message': f"An unexpected error occurred: {str(e)}"}]}

    def _parse_eslint_output(self, eslint_json_output):
        # This parsing logic remains the same
        try:
            data = json.loads(eslint_json_output)
            if not data:
                return {'valid': True, 'errors': [], 'warnings': []}

            file_report = data[0]
            if "fatal" in file_report and file_report["fatal"]:
                return {'valid': False, 'errors': [file_report.get('message', 'Fatal ESLint error')]}

            messages = file_report.get('messages', [])
            errors = [msg for msg in messages if msg.get('severity') == 2]
            warnings = [msg for msg in messages if msg.get('severity') == 1]

            return {
                'valid': len(errors) == 0,
                'errors': errors,
                'warnings': warnings
            }
        except (json.JSONDecodeError, IndexError):
            return {
                'valid': False,
                'errors': [{'message': f"Failed to parse ESLint output: {eslint_json_output}"}]
            }

# --- TEST CASES ---
def code_test():
    # Example of code with a linting error (double quotes)
    jsx_code_with_error = """
    I am an idiot and dumb
    import React from 'react';
    const Component = () => <div>Hello World<div>;
    export default Component;
"""

    # Example of valid code
    jsx_code_correct = """
    import React from 'react';
    const Component = () => <div>Hello World</div>;
    export default Component;
    """

    validator = ESLintValidator()

    print("--- Validating code with a linting error ---")
    result_error = validator.validate_jsx(jsx_code_with_error)
    print(json.dumps(result_error, indent=2))

    print("\n--- Validating correct code ---")
    result_correct = validator.validate_jsx(jsx_code_correct)
    print(json.dumps(result_correct, indent=2))

if __name__ == "__main__":
    code_test()

def clean_up_response(code_string):
    """
    Comprehensive function header removal
    Handles arrow functions, regular functions, and function expressions
    """
    code_string = find_react_code_in_response(code_string)

    # Clean up any extra whitespace
    code_string = code_string.strip()

    patterns = [
        # Arrow functions: () => {, (props) => {, ({prop1, prop2}) => {
        r'^\s*\([^)]*\)\s*=>\s*\{',

        # Regular functions: function() {, function name() {
        r'^\s*function\s*[a-zA-Z_$][a-zA-Z0-9_$]*\s*\([^)]*\)\s*\{',
        r'^\s*function\s*\([^)]*\)\s*\{',

        # Function expressions: const name = () => {, const name = function() {
        r'^\s*const\s+[a-zA-Z_$][a-zA-Z0-9_$]*\s*=\s*\([^)]*\)\s*=>\s*\{',
        r'^\s*const\s+[a-zA-Z_$][a-zA-Z0-9_$]*\s*=\s*function\s*\([^)]*\)\s*\{',

        # Let/var variations
        r'^\s*let\s+[a-zA-Z_$][a-zA-Z0-9_$]*\s*=\s*\([^)]*\)\s*=>\s*\{',
        r'^\s*var\s+[a-zA-Z_$][a-zA-Z0-9_$]*\s*=\s*\([^)]*\)\s*=>\s*\{',
    ]

    for pattern in patterns:
        if re.match(pattern, code_string):
            return re.sub(pattern, '', code_string).strip()

    return code_string.strip()


import re


def find_react_code_in_response(text):
    """
    Extracts React component code from a text response.
    Handles nested components, complex JSX, and various React patterns.

    Returns the first complete React component found, or None if no valid component is detected.
    """

    def is_jsx_element(s):
        """Check if string contains JSX elements"""
        jsx_patterns = [
            r'<[A-Z][a-zA-Z0-9]*[^>]*>',  # Component tags like <MyComponent>
            r'<[a-z]+[^>]*>',  # HTML tags like <div>, <span>
            r'<[^>]+\s*/>',  # Self-closing tags like <img />
            r'{\s*[^}]*\s*}',  # JSX expressions like {variable}
        ]
        return any(re.search(pattern, s) for pattern in jsx_patterns)

    def extract_balanced_braces(text, start_pos):
        """Extract content within balanced braces starting from start_pos"""
        if start_pos >= len(text) or text[start_pos] != '{':
            return None, start_pos

        brace_count = 0
        i = start_pos

        while i < len(text):
            char = text[i]
            if char == '{':
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if brace_count == 0:
                    return text[start_pos:i + 1], i + 1
            i += 1

        return None, start_pos  # Unmatched braces

    def extract_function_body(text, start_pos):
        """Extract complete function body including parameters and body"""
        # Find the opening brace of the function
        brace_pos = text.find('{', start_pos)
        if brace_pos == -1:
            return None

        # Extract the balanced content
        body, end_pos = extract_balanced_braces(text, brace_pos)
        if body is None:
            return None

        # Include everything from start_pos to end_pos
        return text[start_pos:end_pos]

    # Patterns to identify React components
    react_patterns = [
        # Arrow functions: () => {}, (props) => {}, ({prop1, prop2}) => {}
        (r'(\([^)]*\)\s*=>\s*\{)', r'\([^)]*\)\s*=>\s*\{'),

        # Function declarations: function ComponentName() {}, function() {}
        (r'(function\s+[A-Z][a-zA-Z0-9]*\s*\([^)]*\)\s*\{)', r'function\s+[A-Z][a-zA-Z0-9]*\s*\([^)]*\)\s*\{'),
        (r'(function\s*\([^)]*\)\s*\{)', r'function\s*\([^)]*\)\s*\{'),

        # Const/let/var assignments: const Component = () => {}, const Component = function() {}
        (r'(const\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{)',
         r'const\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{'),
        (r'(const\s+[A-Z][a-zA-Z0-9]*\s*=\s*function\s*\([^)]*\)\s*\{)',
         r'const\s+[A-Z][a-zA-Z0-9]*\s*=\s*function\s*\([^)]*\)\s*\{'),
        (r'(let\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{)', r'let\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{'),
        (r'(var\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{)', r'var\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{'),

        # Export statements: export default () => {}, export const Component = () => {}
        (r'(export\s+default\s+\([^)]*\)\s*=>\s*\{)', r'export\s+default\s+\([^)]*\)\s*=>\s*\{'),
        (r'(export\s+const\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{)',
         r'export\s+const\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{'),
    ]

    # Look for direct JSX without function wrapper
    jsx_direct_pattern = r'(<[A-Z][a-zA-Z0-9]*[^>]*>.*?</[A-Z][a-zA-Z0-9]*>|<[a-z]+[^>]*>.*?</[a-z]+>|<[^>]+\s*/>)'

    candidates = []

    # First, try to find function-based components
    for full_pattern, match_pattern in react_patterns:
        for match in re.finditer(match_pattern, text, re.DOTALL | re.IGNORECASE):
            start_pos = match.start()

            # Extract the complete function
            complete_function = extract_function_body(text, start_pos)
            if complete_function and is_jsx_element(complete_function):
                candidates.append((start_pos, complete_function))

    # Also look for direct JSX (might be just JSX without function wrapper)
    for match in re.finditer(jsx_direct_pattern, text, re.DOTALL):
        jsx_content = match.group(1)
        if is_jsx_element(jsx_content):
            candidates.append((match.start(), jsx_content))

    # Return the first (earliest in text) valid React component
    if candidates:
        candidates.sort(key=lambda x: x[0])  # Sort by position in text
        return candidates[0][1]

    return None